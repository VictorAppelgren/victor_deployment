events {
    worker_connections 1024;
}

http {
    # Increase hash bucket size for long API keys
    map_hash_bucket_size 128;

    # Allow large article uploads (10MB)
    client_max_body_size 10M;

    # API Key validation map
    map $http_x_api_key $api_key_valid {
        default 0;
        "785fc6c1647ff650b6b611509cc0a8f47009e6b743340503519d433f111fcf12" 1;  # Key 1 (You)
        "a017a1af6fe167bdfcc554debb1c9a39e2ec75b93adde5a06d11e9a1361344f5" 1;  # Key 2 (Coworker)
        "646b3c9454024ac1f4a2abad35cf1b8d02678b7c98d84059bde4109956adeeec" 1;  # Key 3 (Extra)
    }

    # Upstream services (use Docker Compose service names for DNS)
    upstream backend {
        server apis:8000;
    }

    upstream frontend {
        server frontend:5173;
    }

    upstream neo4j_browser {
        server neo4j:7474;
    }

    upstream qdrant {
        server qdrant:6333;
    }

    upstream mcp {
        server mcp-server:8002;
    }

    # HTTP server - redirect to HTTPS for domains, serve directly for IP/localhost
    server {
        listen 80;
        server_name localhost 167.172.185.204 sagalabs.world www.sagalabs.world;

        # ACME challenge for Let's Encrypt
        location /.well-known/acme-challenge/ {
            root /var/www/certbot;
        }

        # Redirect sagalabs.world to HTTPS, allow IP/localhost on HTTP
        if ($host ~* ^(www\.)?sagalabs\.world$) {
            return 301 https://$host$request_uri;
        }

        # Frontend - Public (for IP/localhost access)
        location / {
            proxy_pass http://frontend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }

        # Auth validation endpoint (internal only - called by auth_request)
        location = /auth/validate {
            internal;
            proxy_pass http://backend/api/validate-session;
            proxy_pass_request_body off;
            proxy_set_header Content-Length "";
            proxy_set_header X-Original-URI $request_uri;
            proxy_set_header Cookie $http_cookie;
            proxy_set_header X-API-Key $http_x_api_key;
        }

        # Login endpoint - NO AUTH REQUIRED
        location = /api/login {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Cookie $http_cookie;
        }

        # Logout endpoint - NO AUTH REQUIRED (needs cookie to invalidate)
        location = /api/logout {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Cookie $http_cookie;
        }

        # Session validation endpoint - NO AUTH (it IS the auth check)
        location = /api/validate-session {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Cookie $http_cookie;
            proxy_set_header X-API-Key $http_x_api_key;
        }

        # Backend API - Validate session OR API key before proxying
        location /api/ {
            # First check if API key is valid (for workers)
            set $skip_auth 0;
            if ($api_key_valid = 1) {
                set $skip_auth 1;
            }

            # If no valid API key, use auth_request to validate session
            auth_request /auth/validate;
            auth_request_set $auth_user $upstream_http_x_auth_user;

            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Cookie $http_cookie;
            proxy_set_header X-Auth-User $auth_user;
        }

        # Neo4j Browser - Public (for development)
        location /neo4j/ {
            proxy_pass http://neo4j_browser/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }

        # Qdrant Vector DB - API key required
        location /qdrant/ {
            if ($http_api_key != "rs9l2Bi7Owb5tooed2FafKXwLhgKbqAtoBi56i_b3Ao") {
                return 401 '{"error": "Invalid API key"}';
            }
            rewrite ^/qdrant/(.*) /$1 break;
            proxy_pass http://qdrant;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # MCP Server - Remote dev access for Claude Code (API key required)
        location /mcp {
            # Require valid API key (same keys as /api/)
            if ($api_key_valid = 0) {
                return 401 '{"error": "Invalid or missing API key"}';
            }
            proxy_pass http://mcp;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-API-Key $http_x_api_key;
            # Longer timeout for deployment operations
            proxy_read_timeout 600s;
            proxy_connect_timeout 60s;
        }
    }

    # HTTPS server for sagalabs.world (only active when certs exist)
    server {
        listen 443 ssl;
        server_name sagalabs.world www.sagalabs.world;

        # SSL certificates from Let's Encrypt
        ssl_certificate /etc/letsencrypt/live/sagalabs.world/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/sagalabs.world/privkey.pem;

        # SSL settings
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 1d;

        # Frontend - Public
        location / {
            proxy_pass http://frontend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }

        # Auth validation endpoint (internal only - called by auth_request)
        location = /auth/validate {
            internal;
            proxy_pass http://backend/api/validate-session;
            proxy_pass_request_body off;
            proxy_set_header Content-Length "";
            proxy_set_header X-Original-URI $request_uri;
            proxy_set_header Cookie $http_cookie;
            proxy_set_header X-API-Key $http_x_api_key;
        }

        # Login endpoint - NO AUTH REQUIRED
        location = /api/login {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Cookie $http_cookie;
        }

        # Logout endpoint - NO AUTH REQUIRED (needs cookie to invalidate)
        location = /api/logout {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Cookie $http_cookie;
        }

        # Session validation endpoint - NO AUTH (it IS the auth check)
        location = /api/validate-session {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Cookie $http_cookie;
            proxy_set_header X-API-Key $http_x_api_key;
        }

        # Backend API - Validate session OR API key before proxying
        location /api/ {
            # First check if API key is valid (for workers)
            set $skip_auth 0;
            if ($api_key_valid = 1) {
                set $skip_auth 1;
            }

            # If no valid API key, use auth_request to validate session
            auth_request /auth/validate;
            auth_request_set $auth_user $upstream_http_x_auth_user;

            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Cookie $http_cookie;
            proxy_set_header X-Auth-User $auth_user;
        }

        # Neo4j Browser - Public (for development)
        location /neo4j/ {
            proxy_pass http://neo4j_browser/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }

        # Qdrant Vector DB - API key required
        location /qdrant/ {
            if ($http_api_key != "rs9l2Bi7Owb5tooed2FafKXwLhgKbqAtoBi56i_b3Ao") {
                return 401 '{"error": "Invalid API key"}';
            }
            rewrite ^/qdrant/(.*) /$1 break;
            proxy_pass http://qdrant;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # MCP Server - Remote dev access for Claude Code (API key required)
        location /mcp {
            # Require valid API key (same keys as /api/)
            if ($api_key_valid = 0) {
                return 401 '{"error": "Invalid or missing API key"}';
            }
            proxy_pass http://mcp;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-API-Key $http_x_api_key;
            # Longer timeout for deployment operations
            proxy_read_timeout 600s;
            proxy_connect_timeout 60s;
        }
    }
}
